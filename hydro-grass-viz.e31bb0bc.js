// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

// eslint-disable-next-line no-global-assign
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  return newRequire;
})({"images/inundation_0.5.png":[function(require,module,exports) {
module.exports = "/inundation_0.5.fb2876f3.png";
},{}],"images/inundation_1.0.png":[function(require,module,exports) {
module.exports = "/inundation_1.0.80b7a708.png";
},{}],"images/inundation_1.5.png":[function(require,module,exports) {
module.exports = "/inundation_1.5.e91d7e2f.png";
},{}],"images/inundation_2.0.png":[function(require,module,exports) {
module.exports = "/inundation_2.0.4e21a309.png";
},{}],"images/inundation_2.5.png":[function(require,module,exports) {
module.exports = "/inundation_2.5.5db84563.png";
},{}],"images/inundation_3.0.png":[function(require,module,exports) {
module.exports = "/inundation_3.0.02fddb01.png";
},{}],"images/inundation_3.5.png":[function(require,module,exports) {
module.exports = "/inundation_3.5.5290314b.png";
},{}],"images/inundation_4.0.png":[function(require,module,exports) {
module.exports = "/inundation_4.0.de794ad2.png";
},{}],"images/inundation_4.5.png":[function(require,module,exports) {
module.exports = "/inundation_4.5.1bd2664d.png";
},{}],"images/inundation_5.0.png":[function(require,module,exports) {
module.exports = "/inundation_5.0.332ae7ac.png";
},{}],"images/simwe/data_file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/* This file was generated by r.out.leaflet GRASS GIS module. */
var layerInfos = [{
  title: "D03_37_20171201_20160228_disch.120",
  file: "D03_37_20171201_20160228_disch.120.png",
  bounds: [[35.74142458, -78.61239861], [35.75521359, -78.62931361]],
  opacity: 1.0
}, {
  title: "D03_37_20079201_20160228_disch.120",
  file: "D03_37_20079201_20160228_disch.120.png",
  bounds: [[35.74162043, -78.67980703], [35.75540014, -78.69671067]],
  opacity: 1.0
}, {
  title: "D03_37_20170101_20160228_disch.120",
  file: "D03_37_20170101_20160228_disch.120.png",
  bounds: [[35.71405388, -78.64622289], [35.72783834, -78.66312646]],
  opacity: 1.0
}, {
  title: "D03_37_20171301_20160228_disch.120",
  file: "D03_37_20171301_20160228_disch.120.png",
  bounds: [[35.76889760, -78.61226696], [35.78268650, -78.62918773]],
  opacity: 1.0
}, {
  title: "D03_37_20079301_20160228_disch.120",
  file: "D03_37_20079301_20160228_disch.120.png",
  bounds: [[35.76909351, -78.67969828], [35.78287312, -78.69660768]],
  opacity: 1.0
}, {
  title: "D03_37_20172203_20160228_disch.120",
  file: "D03_37_20172203_20160228_disch.120.png",
  bounds: [[35.72757609, -78.57876604], [35.74136979, -78.59568383]],
  opacity: 1.0
}, {
  title: "D03_37_20079101_20160228_disch.120",
  file: "D03_37_20079101_20160228_disch.120.png",
  bounds: [[35.71414711, -78.67991570], [35.72792693, -78.69681359]],
  opacity: 1.0
}, {
  title: "D03_37_20171101_20160228_disch.120",
  file: "D03_37_20171101_20160228_disch.120.png",
  bounds: [[35.71395133, -78.61253016], [35.72774044, -78.62943940]],
  opacity: 1.0
}, {
  title: "D03_37_20170301_20160228_disch.120",
  file: "D03_37_20170301_20160228_disch.120.png",
  bounds: [[35.76900022, -78.64598258], [35.78278447, -78.66289767]],
  opacity: 1.0
}, {
  title: "D03_37_20172403_20160228_disch.120",
  file: "D03_37_20172403_20160228_disch.120.png",
  bounds: [[35.78252204, -78.57847985], [35.79631554, -78.59540919]],
  opacity: 1.0
}, {
  title: "D03_37_20170201_20160228_disch.120",
  file: "D03_37_20170201_20160228_disch.120.png",
  bounds: [[35.74152717, -78.64610278], [35.75531153, -78.66301210]],
  opacity: 1.0
}];
var _default = layerInfos;
exports.default = _default;
},{}],"images/simwe/D03_37_20079101_20160228_disch.120.png":[function(require,module,exports) {
module.exports = "/D03_37_20079101_20160228_disch.120.1ab84855.png";
},{}],"images/simwe/D03_37_20079201_20160228_disch.120.png":[function(require,module,exports) {
module.exports = "/D03_37_20079201_20160228_disch.120.a473d1c7.png";
},{}],"images/simwe/D03_37_20079301_20160228_disch.120.png":[function(require,module,exports) {
module.exports = "/D03_37_20079301_20160228_disch.120.cd551e12.png";
},{}],"images/simwe/D03_37_20170101_20160228_disch.120.png":[function(require,module,exports) {
module.exports = "/D03_37_20170101_20160228_disch.120.afadc82a.png";
},{}],"images/simwe/D03_37_20170201_20160228_disch.120.png":[function(require,module,exports) {
module.exports = "/D03_37_20170201_20160228_disch.120.07d44377.png";
},{}],"images/simwe/D03_37_20170301_20160228_disch.120.png":[function(require,module,exports) {
module.exports = "/D03_37_20170301_20160228_disch.120.caa707b7.png";
},{}],"images/simwe/D03_37_20171101_20160228_disch.120.png":[function(require,module,exports) {
module.exports = "/D03_37_20171101_20160228_disch.120.0695c806.png";
},{}],"images/simwe/D03_37_20171201_20160228_disch.120.png":[function(require,module,exports) {
module.exports = "/D03_37_20171201_20160228_disch.120.a0eb09a7.png";
},{}],"images/simwe/D03_37_20171301_20160228_disch.120.png":[function(require,module,exports) {
module.exports = "/D03_37_20171301_20160228_disch.120.5d4fff44.png";
},{}],"images/simwe/D03_37_20172203_20160228_disch.120.png":[function(require,module,exports) {
module.exports = "/D03_37_20172203_20160228_disch.120.8ed3e2ba.png";
},{}],"images/simwe/D03_37_20172403_20160228_disch.120.png":[function(require,module,exports) {
module.exports = "/D03_37_20172403_20160228_disch.120.eaab995d.png";
},{}],"images/simwe/*.png":[function(require,module,exports) {
module.exports = {
  "D03_37_20079101_20160228_disch.120": require("./D03_37_20079101_20160228_disch.120.png"),
  "D03_37_20079201_20160228_disch.120": require("./D03_37_20079201_20160228_disch.120.png"),
  "D03_37_20079301_20160228_disch.120": require("./D03_37_20079301_20160228_disch.120.png"),
  "D03_37_20170101_20160228_disch.120": require("./D03_37_20170101_20160228_disch.120.png"),
  "D03_37_20170201_20160228_disch.120": require("./D03_37_20170201_20160228_disch.120.png"),
  "D03_37_20170301_20160228_disch.120": require("./D03_37_20170301_20160228_disch.120.png"),
  "D03_37_20171101_20160228_disch.120": require("./D03_37_20171101_20160228_disch.120.png"),
  "D03_37_20171201_20160228_disch.120": require("./D03_37_20171201_20160228_disch.120.png"),
  "D03_37_20171301_20160228_disch.120": require("./D03_37_20171301_20160228_disch.120.png"),
  "D03_37_20172203_20160228_disch.120": require("./D03_37_20172203_20160228_disch.120.png"),
  "D03_37_20172403_20160228_disch.120": require("./D03_37_20172403_20160228_disch.120.png")
};
},{"./D03_37_20079101_20160228_disch.120.png":"images/simwe/D03_37_20079101_20160228_disch.120.png","./D03_37_20079201_20160228_disch.120.png":"images/simwe/D03_37_20079201_20160228_disch.120.png","./D03_37_20079301_20160228_disch.120.png":"images/simwe/D03_37_20079301_20160228_disch.120.png","./D03_37_20170101_20160228_disch.120.png":"images/simwe/D03_37_20170101_20160228_disch.120.png","./D03_37_20170201_20160228_disch.120.png":"images/simwe/D03_37_20170201_20160228_disch.120.png","./D03_37_20170301_20160228_disch.120.png":"images/simwe/D03_37_20170301_20160228_disch.120.png","./D03_37_20171101_20160228_disch.120.png":"images/simwe/D03_37_20171101_20160228_disch.120.png","./D03_37_20171201_20160228_disch.120.png":"images/simwe/D03_37_20171201_20160228_disch.120.png","./D03_37_20171301_20160228_disch.120.png":"images/simwe/D03_37_20171301_20160228_disch.120.png","./D03_37_20172203_20160228_disch.120.png":"images/simwe/D03_37_20172203_20160228_disch.120.png","./D03_37_20172403_20160228_disch.120.png":"images/simwe/D03_37_20172403_20160228_disch.120.png"}],"node_modules/@esri/arcgis-to-geojson-utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arcgisToGeoJSON = arcgisToGeoJSON;
exports.geojsonToArcGIS = geojsonToArcGIS;
exports.default = void 0;

/*
 * Copyright 2017 Esri
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// checks if 2 x,y points are equal
function pointsEqual(a, b) {
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
} // checks if the first and last points of a ring are equal and closes the ring


function closeRing(coordinates) {
  if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {
    coordinates.push(coordinates[0]);
  }

  return coordinates;
} // determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring
// or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-
// points-are-in-clockwise-order


function ringIsClockwise(ringToTest) {
  var total = 0;
  var i = 0;
  var rLength = ringToTest.length;
  var pt1 = ringToTest[i];
  var pt2;

  for (i; i < rLength - 1; i++) {
    pt2 = ringToTest[i + 1];
    total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);
    pt1 = pt2;
  }

  return total >= 0;
} // ported from terraformer.js https://github.com/Esri/Terraformer/blob/master/terraformer.js#L504-L519


function vertexIntersectsVertex(a1, a2, b1, b2) {
  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);
  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);
  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);

  if (uB !== 0) {
    var ua = uaT / uB;
    var ub = ubT / uB;

    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return true;
    }
  }

  return false;
} // ported from terraformer.js https://github.com/Esri/Terraformer/blob/master/terraformer.js#L521-L531


function arrayIntersectsArray(a, b) {
  for (var i = 0; i < a.length - 1; i++) {
    for (var j = 0; j < b.length - 1; j++) {
      if (vertexIntersectsVertex(a[i], a[i + 1], b[j], b[j + 1])) {
        return true;
      }
    }
  }

  return false;
} // ported from terraformer.js https://github.com/Esri/Terraformer/blob/master/terraformer.js#L470-L480


function coordinatesContainPoint(coordinates, point) {
  var contains = false;

  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {
    if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {
      contains = !contains;
    }
  }

  return contains;
} // ported from terraformer-arcgis-parser.js https://github.com/Esri/terraformer-arcgis-parser/blob/master/terraformer-arcgis-parser.js#L106-L113


function coordinatesContainCoordinates(outer, inner) {
  var intersects = arrayIntersectsArray(outer, inner);
  var contains = coordinatesContainPoint(outer, inner[0]);

  if (!intersects && contains) {
    return true;
  }

  return false;
} // do any polygons in this array contain any other polygons in this array?
// used for checking for holes in arcgis rings
// ported from terraformer-arcgis-parser.js https://github.com/Esri/terraformer-arcgis-parser/blob/master/terraformer-arcgis-parser.js#L117-L172


function convertRingsToGeoJSON(rings) {
  var outerRings = [];
  var holes = [];
  var x; // iterator

  var outerRing; // current outer ring being evaluated

  var hole; // current hole being evaluated
  // for each ring

  for (var r = 0; r < rings.length; r++) {
    var ring = closeRing(rings[r].slice(0));

    if (ring.length < 4) {
      continue;
    } // is this ring an outer ring? is it clockwise?


    if (ringIsClockwise(ring)) {
      var polygon = [ring.slice().reverse()]; // wind outer rings counterclockwise for RFC 7946 compliance

      outerRings.push(polygon); // push to outer rings
    } else {
      holes.push(ring.slice().reverse()); // wind inner rings clockwise for RFC 7946 compliance
    }
  }

  var uncontainedHoles = []; // while there are holes left...

  while (holes.length) {
    // pop a hole off out stack
    hole = holes.pop(); // loop over all outer rings and see if they contain our hole.

    var contained = false;

    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];

      if (coordinatesContainCoordinates(outerRing, hole)) {
        // the hole is contained push it into our polygon
        outerRings[x].push(hole);
        contained = true;
        break;
      }
    } // ring is not contained in any outer ring
    // sometimes this happens https://github.com/Esri/esri-leaflet/issues/320


    if (!contained) {
      uncontainedHoles.push(hole);
    }
  } // if we couldn't match any holes using contains we can try intersects...


  while (uncontainedHoles.length) {
    // pop a hole off out stack
    hole = uncontainedHoles.pop(); // loop over all outer rings and see if any intersect our hole.

    var intersects = false;

    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];

      if (arrayIntersectsArray(outerRing, hole)) {
        // the hole is contained push it into our polygon
        outerRings[x].push(hole);
        intersects = true;
        break;
      }
    }

    if (!intersects) {
      outerRings.push([hole.reverse()]);
    }
  }

  if (outerRings.length === 1) {
    return {
      type: 'Polygon',
      coordinates: outerRings[0]
    };
  } else {
    return {
      type: 'MultiPolygon',
      coordinates: outerRings
    };
  }
} // This function ensures that rings are oriented in the right directions
// outer rings are clockwise, holes are counterclockwise
// used for converting GeoJSON Polygons to ArcGIS Polygons


function orientRings(poly) {
  var output = [];
  var polygon = poly.slice(0);
  var outerRing = closeRing(polygon.shift().slice(0));

  if (outerRing.length >= 4) {
    if (!ringIsClockwise(outerRing)) {
      outerRing.reverse();
    }

    output.push(outerRing);

    for (var i = 0; i < polygon.length; i++) {
      var hole = closeRing(polygon[i].slice(0));

      if (hole.length >= 4) {
        if (ringIsClockwise(hole)) {
          hole.reverse();
        }

        output.push(hole);
      }
    }
  }

  return output;
} // This function flattens holes in multipolygons to one array of polygons
// used for converting GeoJSON Polygons to ArcGIS Polygons


function flattenMultiPolygonRings(rings) {
  var output = [];

  for (var i = 0; i < rings.length; i++) {
    var polygon = orientRings(rings[i]);

    for (var x = polygon.length - 1; x >= 0; x--) {
      var ring = polygon[x].slice(0);
      output.push(ring);
    }
  }

  return output;
} // shallow object clone for feature properties and attributes
// from http://jsperf.com/cloning-an-object/2


function shallowClone(obj) {
  var target = {};

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      target[i] = obj[i];
    }
  }

  return target;
}

function getId(attributes, idAttribute) {
  var keys = idAttribute ? [idAttribute, 'OBJECTID', 'FID'] : ['OBJECTID', 'FID'];

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];

    if (key in attributes && (typeof attributes[key] === 'string' || typeof attributes[key] === 'number')) {
      return attributes[key];
    }
  }

  throw Error('No valid id attribute found');
}

function arcgisToGeoJSON(arcgis, idAttribute) {
  var geojson = {};

  if (arcgis.features) {
    geojson.type = 'FeatureCollection';
    geojson.features = [];

    for (var i = 0; i < arcgis.features.length; i++) {
      geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));
    }
  }

  if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {
    geojson.type = 'Point';
    geojson.coordinates = [arcgis.x, arcgis.y];

    if (typeof arcgis.z === 'number') {
      geojson.coordinates.push(arcgis.z);
    }
  }

  if (arcgis.points) {
    geojson.type = 'MultiPoint';
    geojson.coordinates = arcgis.points.slice(0);
  }

  if (arcgis.paths) {
    if (arcgis.paths.length === 1) {
      geojson.type = 'LineString';
      geojson.coordinates = arcgis.paths[0].slice(0);
    } else {
      geojson.type = 'MultiLineString';
      geojson.coordinates = arcgis.paths.slice(0);
    }
  }

  if (arcgis.rings) {
    geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));
  }

  if (typeof arcgis.xmin === 'number' && typeof arcgis.ymin === 'number' && typeof arcgis.xmax === 'number' && typeof arcgis.ymax === 'number') {
    geojson.type = 'Polygon';
    geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];
  }

  if (arcgis.geometry || arcgis.attributes) {
    geojson.type = 'Feature';
    geojson.geometry = arcgis.geometry ? arcgisToGeoJSON(arcgis.geometry) : null;
    geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;

    if (arcgis.attributes) {
      try {
        geojson.id = getId(arcgis.attributes, idAttribute);
      } catch (err) {// don't set an id
      }
    }
  } // if no valid geometry was encountered


  if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {
    geojson.geometry = null;
  }

  if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {
    console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));
  }

  return geojson;
}

function geojsonToArcGIS(geojson, idAttribute) {
  idAttribute = idAttribute || 'OBJECTID';
  var spatialReference = {
    wkid: 4326
  };
  var result = {};
  var i;

  switch (geojson.type) {
    case 'Point':
      result.x = geojson.coordinates[0];
      result.y = geojson.coordinates[1];
      result.spatialReference = spatialReference;
      break;

    case 'MultiPoint':
      result.points = geojson.coordinates.slice(0);
      result.spatialReference = spatialReference;
      break;

    case 'LineString':
      result.paths = [geojson.coordinates.slice(0)];
      result.spatialReference = spatialReference;
      break;

    case 'MultiLineString':
      result.paths = geojson.coordinates.slice(0);
      result.spatialReference = spatialReference;
      break;

    case 'Polygon':
      result.rings = orientRings(geojson.coordinates.slice(0));
      result.spatialReference = spatialReference;
      break;

    case 'MultiPolygon':
      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));
      result.spatialReference = spatialReference;
      break;

    case 'Feature':
      if (geojson.geometry) {
        result.geometry = geojsonToArcGIS(geojson.geometry, idAttribute);
      }

      result.attributes = geojson.properties ? shallowClone(geojson.properties) : {};

      if (geojson.id) {
        result.attributes[idAttribute] = geojson.id;
      }

      break;

    case 'FeatureCollection':
      result = [];

      for (i = 0; i < geojson.features.length; i++) {
        result.push(geojsonToArcGIS(geojson.features[i], idAttribute));
      }

      break;

    case 'GeometryCollection':
      result = [];

      for (i = 0; i < geojson.geometries.length; i++) {
        result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));
      }

      break;
  }

  return result;
}

var _default = {
  arcgisToGeoJSON: arcgisToGeoJSON,
  geojsonToArcGIS: geojsonToArcGIS
};
exports.default = _default;
},{}],"index.js":[function(require,module,exports) {
"use strict";

var _inundation_ = _interopRequireDefault(require("./images/inundation_0.5.png"));

var _inundation_2 = _interopRequireDefault(require("./images/inundation_1.0.png"));

var _inundation_3 = _interopRequireDefault(require("./images/inundation_1.5.png"));

var _inundation_4 = _interopRequireDefault(require("./images/inundation_2.0.png"));

var _inundation_5 = _interopRequireDefault(require("./images/inundation_2.5.png"));

var _inundation_6 = _interopRequireDefault(require("./images/inundation_3.0.png"));

var _inundation_7 = _interopRequireDefault(require("./images/inundation_3.5.png"));

var _inundation_8 = _interopRequireDefault(require("./images/inundation_4.0.png"));

var _inundation_9 = _interopRequireDefault(require("./images/inundation_4.5.png"));

var _inundation_10 = _interopRequireDefault(require("./images/inundation_5.0.png"));

var _data_file = _interopRequireDefault(require("./images/simwe/data_file"));

var _ = _interopRequireDefault(require("./images/simwe/*.png"));

var _arcgisToGeojsonUtils = require("@esri/arcgis-to-geojson-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import React, {Component} from 'react';
// import {render} from 'react-dom';
// import {StaticMap} from 'react-map-gl';
// import DeckGL, {ScreenGridLayer} from 'deck.gl';
// import {isWebGL2} from 'luma.gl';
mapboxgl.accessToken = "pk.eyJ1IjoiY3R3aGl0ZSIsImEiOiJjaWtveG9pNGMwejRwdjBrbTAweXZneXR0In0.lB9aylODHdN8w7vAakxeDQ";
var map = new mapboxgl.Map({
  container: 'map',
  zoom: 12,
  center: [-78.6319, 35.7099],
  pitch: 45,
  style: 'mapbox://styles/ctwhite/cjtnhxudz2j4l1fs74h5hygce',
  hash: true
}).addControl(new mapboxgl.NavigationControl()); //Convert Bounds to match mapbox gl source specs

function grassBbox(bounds) {
  return [[bounds[1][1], bounds[1][0]], [bounds[0][1], bounds[1][0]], [bounds[0][1], bounds[0][0]], [bounds[1][1], bounds[0][0]]];
}

map.on('load', function () {
  function setScaleForLevel(scale) {
    var setScale = 15;

    switch (scale) {
      case 'Household':
        setScale = 17;
        break;

      case 'Neighborhood':
        setScale = 15;
        break;

      case 'City':
        setScale = 12;
        break;

      case 'Region':
        setScale = 10;
        break;

      default:
        setScale = 15;
    }

    return setScale;
  }

  function flyToStore(currentFeature) {
    map.flyTo({
      center: currentFeature.geometry.coordinates,
      zoom: setScaleForLevel(currentFeature.properties.what_spatial_scales_does_this_p)
    });
  }

  function createPopUp(currentFeature) {
    var popUps = document.getElementsByClassName('mapboxgl-popup'); // Check if there is already a popup on the map and if so, remove it

    if (popUps[0]) popUps[0].remove();
    var popup = new mapboxgl.Popup({
      closeOnClick: true
    }).setLngLat(currentFeature.geometry.coordinates).setHTML("<h3>".concat(currentFeature.properties.why_is_this_location_a_problem, "</h3>") + '<h4><strong>Difficulty: </strong>' + currentFeature.properties.how_challenging_is_this_problem + '</h4>' + '<h4><strong>Challenge: </strong>' + currentFeature.properties.why_is_this_location_a_problem + '</h4>' + '<h4><strong>Obstacle: </strong>' + currentFeature.properties.what_is_the_greatest_barrier_to + '</h4>' + '<h4><strong>Supplies: </strong>' + currentFeature.properties.what_actions_can_be_taken_to_fi + '</h4>' + '<h4>Get Started!</h4>').addTo(map);
  } // This will let you use the .remove() function later on


  if (!('remove' in Element.prototype)) {
    Element.prototype.remove = function () {
      if (this.parentNode) {
        this.parentNode.removeChild(this);
      }
    };
  } // //Discharge GIF
  // var currentDischargeImage = 0;
  // var dischargeImages = [discharge020, discharge040, discharge060, discharge080, discharge100, discharge120];
  // function getDischargePath() {
  //     return dischargeImages[currentDischargeImage];
  // }
  //Flooding GIF


  var frameCount = 10;
  var currentImage = 9;
  var floodingImages = [_inundation_.default, _inundation_2.default, _inundation_3.default, _inundation_4.default, _inundation_5.default, _inundation_6.default, _inundation_7.default, _inundation_8.default, _inundation_9.default, _inundation_10.default];

  function getPath() {
    return floodingImages[currentImage];
  }

  map.addSource('floodOverlay', {
    type: 'image',
    url: getPath(),
    coordinates: [[-78.7746204947222, 35.8096093825], [-78.6083031766667, 35.8096093825], [-78.6083031766667, 35.6875072969444], [-78.7746204947222, 35.6875072969444]]
  });
  map.addLayer({
    "id": "floodOverlay",
    "source": "floodOverlay",
    "type": "raster",
    "paint": {
      "raster-opacity": 0.85,
      "raster-fade-duration": 0
    }
  }); // setInterval(function() {
  //     currentImage = currentImage + 1;
  //     if (currentImage == 10) {
  //         currentImage = 0;
  //     }
  //     map.getSource("floodOverlay").updateImage({ url: getPath() });
  // }, 200);

  _data_file.default.forEach(function (element) {
    console.log(_.default[element.title]);
    map.addSource(element.title, {
      type: 'image',
      url: _.default[element.title],
      coordinates: grassBbox(element.bounds)
    });
    map.addLayer({
      "id": element.title,
      "source": element.title,
      "type": "raster",
      "paint": {
        "raster-opacity": 0.60,
        "raster-fade-duration": 2
      }
    });
  });

  function buildLevelList(data) {
    if (data.features.length !== levels.length) {
      // Iterate through the list of stores
      for (i = 0; i < data.features.length; i++) {
        var currentFeature = data.features[i]; // Shorten data.feature.properties to `prop` so we're not
        // writing this long form over and over again.

        var prop = currentFeature.properties; // Select the listing container in the HTML and append a div
        // with the class 'item' for each store

        var listings = document.getElementById('listings');
        var listing = listings.appendChild(document.createElement('div'));
        listing.className = 'item';
        listing.id = 'listing-' + i; // Create a new link with the class 'title' for each store
        // and fill it with the store address

        var link = listing.appendChild(document.createElement('a'));
        link.href = '#';
        link.className = 'level-title';
        link.dataPosition = i;
        link.innerHTML = prop.why_is_this_location_a_problem; // Add an event listener for the links in the sidebar listing

        link.addEventListener('click', function (e) {
          // Update the currentFeature to the store associated with the clicked link
          var clickedListing = data.features[this.dataPosition]; // 1. Fly to the point associated with the clicked link

          flyToStore(clickedListing); // 2. Close all other popups and display popup for clicked store

          createPopUp(clickedListing); // 3. Highlight listing in sidebar (and remove highlight for all other listings)

          var activeItem = document.getElementsByClassName('active');

          if (activeItem[0]) {
            activeItem[0].classList.remove('active');
          }

          this.parentNode.classList.add('active');
        }); // Create a new div with the class 'details' for each store
        // and fill it with the city and phone number

        var details = listing.appendChild(document.createElement('div'));
        details.innerHTML = prop.how_challenging_is_this_problem;

        if (prop.phone) {
          details.innerHTML += ' Â· ' + prop.phoneFormatted;
        }
      }
    }
  }

  var levels = fetch("https://services1.arcgis.com/aT1T0pU1ZdpuDk1t/ArcGIS/rest/services/survey123_571499fe84ac4125abe48b793b9970a3_stakeholder/FeatureServer/0/query?f=json&returnGeometry=true&inSR=102100&outFields=*&outSR=4326&where=1=1", {
    cache: "reload"
  }).then(function (res) {
    return res.json();
  }).then(function (json) {
    return (0, _arcgisToGeojsonUtils.arcgisToGeoJSON)(json);
  }).then(function (levels) {
    console.log("levels", levels);
    map.addSource('levels', {
      "type": "geojson",
      "data": levels
    });
    map.addLayer({
      "id": "levels",
      "source": "levels",
      "type": "circle",
      "paint": {
        "circle-radius": 10,
        "circle-color": "#FFE100",
        "circle-opacity": 0.8 // 'fill-extrusion-color': '#FFE100',
        // use an 'interpolate' expression to add a smooth transition effect to the
        // buildings as the user zooms in
        // 'fill-extrusion-height': 100,
        // 'fill-extrusion-base': [
        //     "interpolate", ["linear"], ["zoom"],
        //     14, 0,
        //     14.05, 0
        // ],
        // 'fill-extrusion-opacity': 0.8
        // "type": "symbol",
        // "layout": {
        //     "icon-image": "star-15",
        //     // "text-field": "{title}",
        //     "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
        //     "text-offset": [0, 0.6],
        //     "text-anchor": "top",
        //     "icon-color": "#e00000"
        //     }

      }
    });
    map.addLayer({
      "id": "earthquakes-heat",
      "type": "heatmap",
      "source": "levels",
      "maxzoom": 9,
      "paint": {
        // Increase the heatmap weight based on frequency and property magnitude
        // "heatmap-weight": [
        // "interpolate",
        // ["linear"],
        // ["get", "mag"],
        // 0, 0,
        // 6, 1
        // ],
        // Increase the heatmap color weight weight by zoom level
        // heatmap-intensity is a multiplier on top of heatmap-weight
        "heatmap-intensity": ["interpolate", ["linear"], ["zoom"], 0, 1, 9, 3],
        // Color ramp for heatmap.  Domain is 0 (low) to 1 (high).
        // Begin color ramp at 0-stop with a 0-transparancy color
        // to create a blur-like effect.
        "heatmap-color": ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(33,102,172,0)", 0.2, "rgb(103,169,207)", 0.4, "rgb(209,229,240)", 0.6, "rgb(253,219,199)", 0.8, "rgb(239,138,98)", 1, "rgb(178,24,43)"],
        // Adjust the heatmap radius by zoom level
        "heatmap-radius": ["interpolate", ["linear"], ["zoom"], 0, 2, 9, 20],
        // Transition from heatmap to circle layer by zoom level
        "heatmap-opacity": ["interpolate", ["linear"], ["zoom"], 7, 1, 9, 0]
      }
    });
    buildLevelList(levels); // Add an event listener for when a user clicks on the map

    map.on('click', function (e) {
      // Query all the rendered points in the view
      var selectedFeatureIndex;
      var features = map.queryRenderedFeatures(e.point, {
        layers: ['levels']
      });

      if (features.length) {
        var clickedPoint = features[0]; // 1. Fly to the point

        flyToStore(clickedPoint); // 2. Close all other popups and display popup for clicked store

        createPopUp(clickedPoint); // 3. Highlight listing in sidebar (and remove highlight for all other listings)

        var activeItem = document.getElementsByClassName('active');

        if (activeItem[0]) {
          activeItem[0].classList.remove('active');
        } // Find the index of the store.features that corresponds to the clickedPoint that fired the event listener


        var selectedFeature = clickedPoint.properties.ObjectId;

        for (var i = 0; i < levels.features.length; i++) {
          if (levels.features[i].properties.ObjectId === selectedFeature) {
            selectedFeatureIndex = i;
          }
        } // Select the correct list item using the found index and add the active class


        var listing = document.getElementById('listing-' + selectedFeatureIndex);
        listing.classList.add('active');
      }
    });
    return levels;
  });

  if (!map.getSource('composite')) {
    map.addSource('composite', {
      type: 'vector',
      url: 'mapbox://mapbox.mapbox-streets-v7'
    });
  }

  var layers = map.getStyle().layers;
  var labelLayerId;

  for (var i = 0; i < layers.length; i++) {
    if (layers[i].type === 'symbol' && layers[i].layout['text-field']) {
      labelLayerId = layers[i].id;
      break;
    }
  }

  map.addLayer({
    'id': '3d-buildings',
    'source': 'composite',
    'source-layer': 'building',
    'filter': ['==', 'extrude', 'true'],
    'type': 'fill-extrusion',
    'minzoom': 14,
    'paint': {
      'fill-extrusion-color': '#aaa',
      // use an 'interpolate' expression to add a smooth transition effect to the
      // buildings as the user zooms in
      'fill-extrusion-height': ["interpolate", ["linear"], ["zoom"], 14, 0, 14.05, ["get", "height"]],
      'fill-extrusion-base': ["interpolate", ["linear"], ["zoom"], 14, 0, 14.05, ["get", "min_height"]],
      'fill-extrusion-opacity': 1
    }
  }, labelLayerId); // Add the data to your map as a layer
});
},{"./images/inundation_0.5.png":"images/inundation_0.5.png","./images/inundation_1.0.png":"images/inundation_1.0.png","./images/inundation_1.5.png":"images/inundation_1.5.png","./images/inundation_2.0.png":"images/inundation_2.0.png","./images/inundation_2.5.png":"images/inundation_2.5.png","./images/inundation_3.0.png":"images/inundation_3.0.png","./images/inundation_3.5.png":"images/inundation_3.5.png","./images/inundation_4.0.png":"images/inundation_4.0.png","./images/inundation_4.5.png":"images/inundation_4.5.png","./images/inundation_5.0.png":"images/inundation_5.0.png","./images/simwe/data_file":"images/simwe/data_file.js","./images/simwe/*.png":"images/simwe/*.png","@esri/arcgis-to-geojson-utils":"node_modules/@esri/arcgis-to-geojson-utils/index.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "61656" + '/');

  ws.onmessage = function (event) {
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      console.clear();
      data.assets.forEach(function (asset) {
        hmrApply(global.parcelRequire, asset);
      });
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          hmrAccept(global.parcelRequire, asset.id);
        }
      });
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] âœ¨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] ðŸš¨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">ðŸš¨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAccept(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAccept(bundle.parent, id);
  }

  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAccept(global.parcelRequire, id);
  });
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.js"], null)
//# sourceMappingURL=/hydro-grass-viz.e31bb0bc.map